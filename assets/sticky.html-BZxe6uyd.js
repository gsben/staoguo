import{_ as l,c as a,d as n,o as s}from"./app-C0p4sjhn.js";const i={};function t(u,e){return s(),a("div",null,e[0]||(e[0]=[n('<h1 id="vue2-和-vue3-的区别" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3-的区别"><span>Vue2 和 Vue3 的区别</span></a></h1><h2 id="_1-响应式系统-reactivity-system" tabindex="-1"><a class="header-anchor" href="#_1-响应式系统-reactivity-system"><span>1. 响应式系统（Reactivity System）</span></a></h2><h3 id="vue2" tabindex="-1"><a class="header-anchor" href="#vue2"><span>Vue2:</span></a></h3><ul><li>Vue2 使用基于 <code>Object.defineProperty</code> 的响应式系统，通过劫持对象的 getter 和 setter 来追踪依赖并更新视图。</li><li>缺点：性能开销较大，尤其是在大型数据结构和深层嵌套的对象上。并且 <code>Object.defineProperty</code> 无法监控新增的属性（需要使用 <code>Vue.set</code> 或 <code>this.$set</code>）。</li></ul><h3 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3"><span>Vue3:</span></a></h3><ul><li>Vue3 使用基于 <code>Proxy</code> 的响应式系统，对整个对象进行代理，能拦截并处理所有操作。</li><li>优点： <ul><li>支持深层次的响应式变化，新增属性也能被自动追踪。</li><li>性能大幅提升，尤其是在处理大量数据时。</li></ul></li></ul><h2 id="_2-composition-api" tabindex="-1"><a class="header-anchor" href="#_2-composition-api"><span>2. Composition API</span></a></h2><h3 id="vue2-1" tabindex="-1"><a class="header-anchor" href="#vue2-1"><span>Vue2:</span></a></h3><ul><li>Vue2 使用的是 <strong>Options API</strong>，组件的逻辑通过 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 等选项组织。这种方式对复杂组件的逻辑模块化较为困难，特别是在组件较为复杂时。</li></ul><h3 id="vue3-1" tabindex="-1"><a class="header-anchor" href="#vue3-1"><span>Vue3:</span></a></h3><ul><li>Vue3 引入了 <strong>Composition API</strong>，通过 <code>setup()</code> 函数组织组件逻辑，使得代码更加模块化和可复用。</li><li>使用 <code>ref</code> 和 <code>reactive</code> 创建响应式数据，<code>computed</code> 和 <code>watch</code> 用于计算属性和监听。</li></ul><h2 id="_3-性能优化" tabindex="-1"><a class="header-anchor" href="#_3-性能优化"><span>3. 性能优化</span></a></h2><h3 id="vue2-2" tabindex="-1"><a class="header-anchor" href="#vue2-2"><span>Vue2:</span></a></h3><ul><li>性能优化较为基础，主要通过虚拟 DOM 和懒加载等技术进行提升。性能上可能存在一些瓶颈，尤其是在处理复杂数据时。</li></ul><h3 id="vue3-2" tabindex="-1"><a class="header-anchor" href="#vue3-2"><span>Vue3:</span></a></h3><ul><li>Vue3 在启动和内存消耗上得到了显著提升。采用 <code>Proxy</code> 使得响应式系统性能更强，减少了性能开销。</li><li>进一步优化虚拟 DOM 渲染，树摇优化（Tree-shaking）可以去除未使用的代码，使得构建后的包体积更小。</li></ul><h2 id="_4-typescript-支持" tabindex="-1"><a class="header-anchor" href="#_4-typescript-支持"><span>4. TypeScript 支持</span></a></h2><h3 id="vue2-3" tabindex="-1"><a class="header-anchor" href="#vue2-3"><span>Vue2:</span></a></h3><ul><li>Vue2 对 TypeScript 支持较为有限，官方提供的类型定义不完整，需要依赖第三方库增强类型支持。</li></ul><h3 id="vue3-3" tabindex="-1"><a class="header-anchor" href="#vue3-3"><span>Vue3:</span></a></h3><ul><li>Vue3 提供了原生的 TypeScript 支持，几乎所有的功能都可以通过 TypeScript 类型定义。这使得开发者能够充分利用 TypeScript 提升开发体验。</li></ul><h2 id="_5-生命周期钩子" tabindex="-1"><a class="header-anchor" href="#_5-生命周期钩子"><span>5. 生命周期钩子</span></a></h2><h3 id="vue2-4" tabindex="-1"><a class="header-anchor" href="#vue2-4"><span>Vue2:</span></a></h3><ul><li>Vue2 中的生命周期钩子如 <code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 等。</li></ul><h3 id="vue3-4" tabindex="-1"><a class="header-anchor" href="#vue3-4"><span>Vue3:</span></a></h3><ul><li>Vue3 中的生命周期钩子以函数形式出现在 <code>setup()</code> 中，命名方式有所变化。例如，<code>beforeMount</code> 变成了 <code>onBeforeMount</code>，<code>mounted</code> 变成了 <code>onMounted</code> 等。</li></ul><h2 id="_6-fragment、teleport-和-suspense" tabindex="-1"><a class="header-anchor" href="#_6-fragment、teleport-和-suspense"><span>6. Fragment、Teleport 和 Suspense</span></a></h2><h3 id="vue2-5" tabindex="-1"><a class="header-anchor" href="#vue2-5"><span>Vue2:</span></a></h3><ul><li>Vue2 中每个组件只能有一个根元素，如果需要多个根元素，通常需要使用一个 <code>div</code> 包裹。</li></ul><h3 id="vue3-5" tabindex="-1"><a class="header-anchor" href="#vue3-5"><span>Vue3:</span></a></h3><ul><li><strong>Fragment</strong>：允许一个组件有多个根元素，而无需额外的包裹元素。</li><li><strong>Teleport</strong>：使得你可以将子组件的内容渲染到 DOM 中的其他位置（例如 <code>#app</code> 外部）。</li><li><strong>Suspense</strong>：处理异步组件加载状态，类似 React 的 Suspense，可以显示加载中的占位内容。</li></ul><h2 id="_7-自定义渲染器-custom-renderer" tabindex="-1"><a class="header-anchor" href="#_7-自定义渲染器-custom-renderer"><span>7. 自定义渲染器（Custom Renderer）</span></a></h2><h3 id="vue2-6" tabindex="-1"><a class="header-anchor" href="#vue2-6"><span>Vue2:</span></a></h3><ul><li>Vue2 的渲染机制是基于虚拟 DOM，但没有特别设计的 API 来创建自定义渲染器。</li></ul><h3 id="vue3-6" tabindex="-1"><a class="header-anchor" href="#vue3-6"><span>Vue3:</span></a></h3><ul><li>Vue3 提供了更加灵活的 <strong>自定义渲染器 API</strong>，允许开发者创建自定义的渲染机制，例如渲染到 Canvas 或 WebGL。</li></ul><h2 id="_8-全局-api" tabindex="-1"><a class="header-anchor" href="#_8-全局-api"><span>8. 全局 API</span></a></h2><h3 id="vue2-7" tabindex="-1"><a class="header-anchor" href="#vue2-7"><span>Vue2:</span></a></h3><ul><li>Vue2 中很多 API 是全局的，直接挂载到 <code>Vue</code> 实例上，如 <code>Vue.use</code>、<code>Vue.component</code>、<code>Vue.mixin</code> 等。</li></ul><h3 id="vue3-7" tabindex="-1"><a class="header-anchor" href="#vue3-7"><span>Vue3:</span></a></h3><ul><li>Vue3 将全局 API 重构为通过 <strong><code>app</code> 实例进行挂载</strong>，例如 <code>app.use()</code> 替代 <code>Vue.use()</code>，<code>app.component()</code> 替代 <code>Vue.component()</code> 等。</li></ul><h2 id="_9-scoped-slots" tabindex="-1"><a class="header-anchor" href="#_9-scoped-slots"><span>9. Scoped Slots</span></a></h2><h3 id="vue2-8" tabindex="-1"><a class="header-anchor" href="#vue2-8"><span>Vue2:</span></a></h3><ul><li>Vue2 中的 <strong>Scoped Slots</strong> 语法较为复杂，需要通过插槽作用域传递数据。</li></ul><h3 id="vue3-8" tabindex="-1"><a class="header-anchor" href="#vue3-8"><span>Vue3:</span></a></h3><ul><li>Vue3 改进了 <strong>Scoped Slots</strong> 的语法，变得更加简洁和直观，传递的数据也更加清晰。</li></ul><h2 id="_10-tree-shaking-和构建工具" tabindex="-1"><a class="header-anchor" href="#_10-tree-shaking-和构建工具"><span>10. Tree Shaking 和构建工具</span></a></h2><h3 id="vue2-9" tabindex="-1"><a class="header-anchor" href="#vue2-9"><span>Vue2:</span></a></h3><ul><li>Vue2 的构建工具较为基础，虽然可以通过 Webpack 等工具进行优化，但对 Tree Shaking 支持有限。</li></ul><h3 id="vue3-9" tabindex="-1"><a class="header-anchor" href="#vue3-9"><span>Vue3:</span></a></h3><ul><li>Vue3 支持 <strong>Tree Shaking</strong>，可以大大减少最终的打包体积，并且优化了构建工具和插件，构建速度更快。</li></ul><h2 id="_11-其他新特性" tabindex="-1"><a class="header-anchor" href="#_11-其他新特性"><span>11. 其他新特性</span></a></h2><ul><li><strong>Provide/Inject</strong>：Vue3 对 <code>provide/inject</code> API 进行了改进，使用更为简洁直观。</li><li><strong>Suspense &amp; Async Components</strong>：Vue3 支持异步组件加载时显示占位符，并提供更简单的处理方式。</li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><strong>Vue3</strong> 引入了很多新特性和优化，最重要的是 <strong>响应式系统</strong> 和 <strong>Composition API</strong>，使得开发更加灵活和高效，尤其在性能方面得到了大幅提升。</li><li><strong>Vue2</strong> 仍然是一个成熟且稳定的框架，许多企业和项目仍在使用 Vue2，特别是在一些老旧项目中。对于新项目，Vue3 提供了更好的选择，而对于旧项目，Vue2 依然能满足需求。</li></ul>',56)]))}const c=l(i,[["render",t]]),o=JSON.parse('{"path":"/posts/sticky.html","title":"Vue2 和 Vue3 的区别","lang":"en-US","frontmatter":{"date":"2025-04-06T00:00:00.000Z","category":["front"],"tag":["vue"],"sticky":true,"excerpt":"<p>vue2 和 vue3 的对比</p>"},"headers":[{"level":2,"title":"1. 响应式系统（Reactivity System）","slug":"_1-响应式系统-reactivity-system","link":"#_1-响应式系统-reactivity-system","children":[{"level":3,"title":"Vue2:","slug":"vue2","link":"#vue2","children":[]},{"level":3,"title":"Vue3:","slug":"vue3","link":"#vue3","children":[]}]},{"level":2,"title":"2. Composition API","slug":"_2-composition-api","link":"#_2-composition-api","children":[{"level":3,"title":"Vue2:","slug":"vue2-1","link":"#vue2-1","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-1","link":"#vue3-1","children":[]}]},{"level":2,"title":"3. 性能优化","slug":"_3-性能优化","link":"#_3-性能优化","children":[{"level":3,"title":"Vue2:","slug":"vue2-2","link":"#vue2-2","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-2","link":"#vue3-2","children":[]}]},{"level":2,"title":"4. TypeScript 支持","slug":"_4-typescript-支持","link":"#_4-typescript-支持","children":[{"level":3,"title":"Vue2:","slug":"vue2-3","link":"#vue2-3","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-3","link":"#vue3-3","children":[]}]},{"level":2,"title":"5. 生命周期钩子","slug":"_5-生命周期钩子","link":"#_5-生命周期钩子","children":[{"level":3,"title":"Vue2:","slug":"vue2-4","link":"#vue2-4","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-4","link":"#vue3-4","children":[]}]},{"level":2,"title":"6. Fragment、Teleport 和 Suspense","slug":"_6-fragment、teleport-和-suspense","link":"#_6-fragment、teleport-和-suspense","children":[{"level":3,"title":"Vue2:","slug":"vue2-5","link":"#vue2-5","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-5","link":"#vue3-5","children":[]}]},{"level":2,"title":"7. 自定义渲染器（Custom Renderer）","slug":"_7-自定义渲染器-custom-renderer","link":"#_7-自定义渲染器-custom-renderer","children":[{"level":3,"title":"Vue2:","slug":"vue2-6","link":"#vue2-6","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-6","link":"#vue3-6","children":[]}]},{"level":2,"title":"8. 全局 API","slug":"_8-全局-api","link":"#_8-全局-api","children":[{"level":3,"title":"Vue2:","slug":"vue2-7","link":"#vue2-7","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-7","link":"#vue3-7","children":[]}]},{"level":2,"title":"9. Scoped Slots","slug":"_9-scoped-slots","link":"#_9-scoped-slots","children":[{"level":3,"title":"Vue2:","slug":"vue2-8","link":"#vue2-8","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-8","link":"#vue3-8","children":[]}]},{"level":2,"title":"10. Tree Shaking 和构建工具","slug":"_10-tree-shaking-和构建工具","link":"#_10-tree-shaking-和构建工具","children":[{"level":3,"title":"Vue2:","slug":"vue2-9","link":"#vue2-9","children":[]},{"level":3,"title":"Vue3:","slug":"vue3-9","link":"#vue3-9","children":[]}]},{"level":2,"title":"11. 其他新特性","slug":"_11-其他新特性","link":"#_11-其他新特性","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1746875376000,"contributors":[{"name":"gsben","username":"gsben","email":"704684827@qq.com","commits":2,"url":"https://github.com/gsben"}],"changelog":[{"hash":"1cc1e1af9d88c615888ce5bde0368326f65f45d1","time":1746875376000,"email":"704684827@qq.com","author":"gsben","message":"提交一版"},{"hash":"fedb5cc9654cc7c06da94ed6b6caf3e2b9f1234d","time":1743828315000,"email":"704684827@qq.com","author":"gsben","message":"init"}]},"filePathRelative":"posts/sticky.md"}');export{c as comp,o as data};
